<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Русский дурак (подкидной/переводной, суперсилы, анимация)</title>
<style>
  :root {
    --table-bg: #0c4a2b;
    --felt: #116d3d;
    --card-w: 80px;
    --card-h: 120px;
    --card-radius: 8px;
    --accent: #ffd166;
    --danger: #ef476f;
    --ok: #06d6a0;
    --muted: #a5b4c0;
  }
  * { box-sizing: border-box; }
  body {
    margin: 0;
    background: #0b3d27;
    color: #f1f5f9;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Liberation Sans", sans-serif;
  }
  header, footer {
    padding: 10px 14px;
    background: #072a1b;
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 12px;
    flex-wrap: wrap;
  }
  header h1 {
    font-size: 18px;
    margin: 0;
  }
  .hud { display:none; }
  .toolbar {
    display: flex;
    gap: 8px;
    flex-wrap: wrap;
    align-items: center;
    justify-content: center;
    padding: 6px 6px 2px;
  }
  .group {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    padding: 6px 8px;
    background: #0d2f20;
    border: 1px solid #1b5a3b;
    border-radius: 8px;
  }
  .group .title { font-size: 12px; color: var(--muted); letter-spacing: 0.2px; display: inline-flex; align-items: center; gap: 6px; cursor: pointer; user-select: none; }
  .group .arrow { width: 0; height: 0; border-left: 5px solid transparent; border-right: 5px solid transparent; border-top: 7px solid #8fbfa8; transition: transform 0.18s ease; opacity: 0.9; }
  .group.collapsed .arrow { transform: rotate(-90deg); }
  .group-content { display: inline-flex; align-items: center; gap: 6px; }
  .group.collapsed .group-content { display: none; }
  .btn {
    background: #1f6f4a;
    border: 1px solid #2ea86f;
    color: #fff;
    padding: 8px 12px;
    border-radius: 6px;
    cursor: pointer;
    font-weight: 600;
  }
  .btn:disabled {
    opacity: 0.5;
    cursor: default;
  }
  .btn.secondary { background: #273c2c; border-color: #446b52; }
  .btn.danger { background: #7a1a2f; border-color: #ef476f; }
  .btn.warn { background: #6c4a00; border-color: #ffb703; }
  .btn.info { background: #0e4a7a; border-color: #2ea0ff; }
  .btn.small { padding: 6px 10px; font-size: 14px; }
  .btn.toggle { background: #24425c; border-color: #4e85b3; }
  .badge { display: inline-block; padding: 2px 6px; border-radius: 999px; background: #214f39; border: 1px solid #3a7d5a; font-size: 12px; }
  .switch {
    display: inline-flex; align-items: center; gap: 6px;
    padding: 4px 8px; border-radius: 999px; border: 1px solid #3a7d5a; background: #214f39; font-size: 13px;
  }
  .switch input { transform: translateY(1px); }
  .mode-note { color: var(--muted); font-size: 12px; margin-left: 4px; opacity: 0.9; }

  /* Table layout */
  .table {
    height: calc(100vh - 190px);
    min-height: 560px;
    background: radial-gradient(ellipse at center, var(--felt), var(--table-bg) 70%);
    position: relative;
    overflow: hidden;
  }
  .area {
    position: absolute;
    left: 50%;
    transform: translateX(-50%);
    width: min(1100px, 96vw);
    padding: 10px;
  }
  .opponent-area { top: 8px; z-index: 1; }
  .center-area { top: 32%; z-index: 3; }
  .player-area { bottom: 8px; z-index: 2; }

  /* Deck + trump */
  .deck-zone {
    position: absolute;
    right: 20px;
    top: 50%;
    transform: translateY(-50%);
    width: calc(var(--card-w) + 16px);
  }
  .pile {
    position: relative;
    width: var(--card-w);
    height: var(--card-h);
    margin: 6px auto;
  }
  .pile .card {
    position: absolute;
    top: 0; left: 0;
  }
  .count-label {
    text-align: center;
    font-size: 14px;
    color: #d1fae5;
    margin-top: 4px;
  }
  .trump-badge {
    text-align: center;
    margin-top: 4px;
    font-size: 14px;
    color: var(--accent);
    font-weight: 700;
  }
  .trump-badge.double-on {
    text-shadow: 0 0 8px rgba(255,209,102,0.6);
  }
  .trump-badge.double-on::after {
    content: ' ×2';
  }
  .trump-badge.flash { animation: pulseBadge 0.6s ease 1; }
  @keyframes pulseBadge {
    0% { transform: scale(1); box-shadow: 0 0 0 0 rgba(255,209,102,0.0); }
    50% { transform: scale(1.06); box-shadow: 0 0 12px 2px rgba(255,209,102,0.7); }
    100% { transform: scale(1); box-shadow: 0 0 0 0 rgba(255,209,102,0.0); }
  }

  /* Cards */
  .hand {
    display: grid;
    grid-auto-flow: column;
    grid-auto-columns: var(--card-w);
    justify-content: start;
    gap: 8px;
    padding: 10px 16px;
    min-height: calc(var(--card-h) + 20px);
    overflow-x: auto;
    overflow-y: hidden;
    cursor: grab;
    -webkit-overflow-scrolling: touch;
    scroll-behavior: smooth;
    touch-action: pan-x;
    overscroll-behavior-x: contain;
  }
  /* Two-rows layout for mobile when many cards in player's hand */
  .hand.two-rows {
    grid-auto-flow: row;
    grid-template-columns: repeat(auto-fill, var(--card-w));
    grid-auto-rows: var(--card-h);
    min-height: calc(var(--card-h) * 2 + 20px);
    height: calc(var(--card-h) * 2 + 20px);
    overflow-x: hidden;
    row-gap: 8px;
    z-index: 2; /* ниже центра стола */
  }
  .hand.dragging { cursor: grabbing; }
  .card {
    width: var(--card-w);
    height: var(--card-h);
    background: #fff;
    color: #111;
    border-radius: var(--card-radius);
    box-shadow: 0 6px 14px rgba(0,0,0,0.35);
    border: 1px solid #eee;
    position: relative;
    user-select: none;
    z-index: 1;
  }
  .card.face-down {
    background: repeating-linear-gradient(45deg, #0e3b27, #0e3b27 6px, #12563a 6px, #12563a 12px);
    border-color: #0b2a1b;
  }
  /* Hidden second trump under face-up trump: make it more visible */
  .card.face-down.hidden-under-trump {
    background: repeating-linear-gradient(45deg, #0e3b27, #0e3b27 6px, #1b7c50 6px, #1b7c50 12px);
    border-color: #1b7c50;
    box-shadow: 0 0 0 2px rgba(255,209,102,0.55) inset, 0 2px 8px rgba(0,0,0,0.35);
  }
  .card .rank {
    position: absolute;
    top: 6px; left: 8px;
    font-size: 18px;
    font-weight: 700;
  }
  .card .suit {
    position: absolute;
    bottom: 6px; right: 8px;
    font-size: 18px;
  }
  .card.red { color: #c1121f; }
  .card .small-suit {
    position: absolute;
    bottom: 6px; left: 8px;
    font-size: 14px;
    opacity: 0.8;
  }
  .card .corner-rank {
    position: absolute;
    top: 6px; right: 8px;
    font-size: 14px;
    opacity: 0.7;
  }
  .card.clickable { cursor: pointer; outline: 2px solid transparent; }
  .card.valid { outline-color: #06d6a0; outline-offset: 2px; }
  .card.transfer { outline-color: #ffd166; outline-offset: 2px; box-shadow: 0 0 10px rgba(255,209,102,0.6); }

  /* Table pairs */
  .table-pairs {
    display: grid;
    grid-template-columns: repeat(6, var(--card-w));
    gap: 14px 14px;
    justify-content: center;
    padding: 10px;
    min-height: calc(var(--card-h) + 20px);
  }
  .pair {
    width: var(--card-w);
    height: calc(var(--card-h) * 2 + 10px);
    position: relative;
    z-index: 3;
  }
  .pair .card.attack {
    position: absolute;
    top: 0; left: 0;
    z-index: 3;
  }
  .pair .card.defense {
    position: absolute;
    top: 26px; left: 12px;
    transform: rotate(5deg);
    z-index: 3;
  }
  .pair.open .card.attack { filter: drop-shadow(0 0 6px rgba(255,215,0,0.6)); }

  /* Opponent display */
  .opponent-info {
    display: flex;
    justify-content: center;
    gap: 12px;
    align-items: center;
    font-size: 14px;
    color: #e6fff3;
  }
  @media (max-width: 480px) {
    .opponent-info { font-size: 12px; }
  }

  /* Log/messages */
  .log {
    font-size: 14px;
    color: #d7fbe8;
    text-align: center;
  }
  .log strong { color: var(--accent); }

  /* Toasts */
  .toast-container { position: fixed; top: 10px; left: 50%; transform: translateX(-50%); z-index: 10000; }
  .toast {
    background: rgba(23,32,42,0.92);
    border: 1px solid rgba(255,255,255,0.15);
    color: #fff; padding: 8px 12px; margin-top: 8px; border-radius: 8px;
    box-shadow: 0 6px 16px rgba(0,0,0,0.35); font-size: 14px; white-space: nowrap;
  }

  /* Confetti */
  .confetti { position: fixed; width: 8px; height: 12px; opacity: 0.9; z-index: 9999; will-change: transform, opacity; }

  /* Controls bar */
  .controls {
    display: flex;
    gap: 10px;
    justify-content: center;
    margin-top: 6px;
    flex-wrap: wrap;
  }

  /* Mobile adaptations */
  @media (max-width: 768px) {
    .toolbar { gap: 6px; justify-content: flex-start; overflow-x: auto; padding: 6px; }
    .group { padding: 4px 6px; }
    .btn.small { font-size: 12px; padding: 4px 8px; }
    .badge { font-size: 11px; padding: 2px 5px; }
    .controls { position: sticky; bottom: 6px; background: rgba(7,42,27,0.55); border: 1px solid #1b5a3b; padding: 8px 10px; border-radius: 10px; backdrop-filter: blur(6px); }
  }

  /* Phones portrait: smaller cards, 3 columns on table */
  @media (max-width: 480px) and (orientation: portrait) {
    :root { --card-w: 56px; --card-h: 84px; }
    .table-pairs { grid-template-columns: repeat(3, var(--card-w)); gap: 10px 10px; }
    .hand { justify-content: start; gap: 6px; padding: 8px 22px; padding-right: 24px; min-height: calc(var(--card-h) + 10px); }
    .opponent-area .hand { min-height: calc(var(--card-h) * 0.8); }
    .deck-zone { right: 8px; }
  }

  /* Phones landscape and small tablets: 4 columns on table */
  @media (max-width: 768px) and (orientation: landscape) {
    :root { --card-w: 66px; --card-h: 100px; }
    .table-pairs { grid-template-columns: repeat(4, var(--card-w)); gap: 12px 12px; }
    .hand { justify-content: start; gap: 6px; padding: 8px 22px; padding-right: 24px; }
    .deck-zone { right: 10px; }
  }

  /* Flying card (deal animation) */
  .flying-card {
    position: fixed;
    width: var(--card-w);
    height: var(--card-h);
    z-index: 9999;
    transition: transform 0.45s ease, opacity 0.45s ease;
    will-change: transform, opacity;
    pointer-events: none;
  }

  /* Busy overlay to prevent clicks during dealing */
  .busy-overlay {
    position: absolute;
    inset: 0;
    background: rgba(0,0,0,0.0);
    pointer-events: none;
  }
  .busy .busy-overlay {
    background: rgba(0,0,0,0.0);
    pointer-events: all;
  }
</style>
</head>
<body>
<header>
  <h1>Русский дурак</h1>
  <div class="toolbar">
    <div class="group" id="group-status">
      <span class="title"><span class="arrow"></span>Статус</span>
      <div class="group-content">
        <span class="badge" id="turnBadge">Ходит: —</span>
        <span class="badge" id="statusBadge">Новая игра</span>
        <span class="badge" id="scoreBadge">Счёт: Вы <span id="playerScore">0</span> — ИИ <span id="aiScore">0</span></span>
        <span class="badge" id="superBadge">Суперсила: доступна</span>
      </div>
    </div>
    <div class="group" id="group-game">
      <span class="title"><span class="arrow"></span>Игра</span>
      <div class="group-content">
        <button class="btn small" id="newGameBtn">Новая игра</button>
        <button class="btn small" id="resetScoreBtn">Сброс счёта</button>
      </div>
    </div>
    <div class="group" id="group-super">
      <span class="title"><span class="arrow"></span>Супер</span>
      <div class="group-content">
        <button class="btn small info" id="peekBtn">Подсмотреть</button>
        <button class="btn small warn" id="swapBtn">Сменить руку</button>
      </div>
    </div>
    <div class="group" id="group-modes">
      <span class="title"><span class="arrow"></span>Режимы</span>
      <div class="group-content">
        <label class="switch">
          <input type="checkbox" id="transferModeChk"/>
          Переводной <span id="transferNote" class="mode-note"></span>
        </label>
        <label class="switch">
          <input type="checkbox" id="doubleTrumpChk"/>
          Двойной козырь <span id="trumpNote" class="mode-note"></span>
        </label>
        <button class="btn small toggle" id="fastBtn">Раздача: норм</button>
          <span class="title" style="margin-left:6px">Размер карт</span>
          <button class="btn small secondary" id="zoomOutBtn" title="Уменьшить карты">−</button>
          <button class="btn small" id="zoomInBtn" title="Увеличить карты">+</button>
      </div>
    </div>
  </div>
</header>

<div class="table" id="table">
  <div class="area opponent-area">
    <div class="opponent-info">
      Противник: <span id="opCount">0</span> карт
    </div>
    <div class="hand" id="opHand"></div>
  </div>

  <div class="area center-area">
    <div class="table-pairs" id="pairs"></div>
  </div>

  <div class="deck-zone">
    <div class="pile" id="deckPile"></div>
    <div class="count-label">В колоде: <span id="deckCount">0</span></div>
    <div class="trump-badge">Козырь: <span id="trumpSuit">—</span></div>
    <div class="count-label">Бито: <span id="discardCount">0</span></div>
  </div>

  <div class="area player-area">
    <div class="hand" id="playerHand"></div>
    <div class="controls">
      <div class="group">
        <span class="title">Ход</span>
        <button class="btn small" id="endAttackBtn2" disabled>Бито</button>
        <button class="btn small danger" id="takeBtn2" disabled>Взять</button>
      </div>
      <div class="log" id="log">Подсказки будут здесь.</div>
    </div>
  </div>

  <div class="busy-overlay"></div>
</div>

<footer>
  <details id="rulesDetails">
    <summary>Правила</summary>
    <div style="margin-top:6px">36 карт (6–Туз). Козырь — масть нижней карты колоды. Добор до 6 (сначала атакующий). Защитник может взять. Атакующий — «бито». Подкидка: на первом ходе взятки максимум 5 карт; далее — до последней карты защитника (в руке должна остаться как минимум 1 карта). «Переводной» режим: защитник вместо побития может перевести, добавив карту того же ранга (если укладывается в лимиты), стороны меняются ролями. «Двойной козырь»: под козырной картой лежит скрытая карта; когда из колоды вышли все карты (включая первый козырь), она вскрывается и её масть становится новым козырем.</div>
  </details>
</footer>

<script>
(function() {
  // Game constants
  const RANKS = ['6','7','8','9','10','В','Д','K','Т'];
  const RANK_VALUE = { '6':6,'7':7,'8':8,'9':9,'10':10,'В':11,'Д':12,'K':13,'Т':14 };
  const SUITS = ['♠','♥','♦','♣'];
  const RED_SUITS = new Set(['♥','♦']);
  const HAND_SIZE = 6;

  // State
  const state = {
    deck: [],
    discard: [],
    tablePairs: [], // [{attack: card, defense: card|null}]
    trumpSuit: null,
    trumpRefRank: null,
    // Double trump mode
    doubleTrumpActive: false,   // applies to current round only
    doubleTrumpPlanned: false,  // checkbox preference, applies on next New Game
    secondTrumpCard: null,
    secondTrumpRevealed: false,
    prevTrumpSuit: null,
    prevTrumpRefRank: null,
    revealAnimating: false,
    player: { hand: [], name: 'Игрок' },
    ai: { hand: [], name: 'ИИ' },
    attacker: 'player', // 'player' or 'ai'
    phase: 'idle',      // 'attack', 'defense', 'adding', 'ai_turn', 'between'
    message: '',
    gameOver: false,
    playerScore: 0,
    aiScore: 0,
    isDealing: false,
    // Dealing resume context
    dealContext: null, // 'initial' | 'refill' | null
    dealAttackerFirst: true,
    postDeal: null, // { type: 'successfulDefense' | 'defenderTakes' } | null
    // Superpowers
    superUsed: false,
    peekActive: false,
    // Mode
    transferMode: false,          // applies to current round only
    transferModePlanned: false,   // checkbox preference, applies on next New Game
    // Lightweight memory for AI
    memory: {
      playerDislikeScore: { '♠': 0, '♥': 0, '♦': 0, '♣': 0 },
      seenDiscardIds: new Set(),
      mashCombo: 0,
      lastMashTs: 0
    },
    fastDeal: false,
    boutStartDefHand: null
  };

  // DOM
  const el = {
    tableRoot: document.getElementById('table'),
    playerHand: document.getElementById('playerHand'),
    opHand: document.getElementById('opHand'),
    pairs: document.getElementById('pairs'),
    deckPile: document.getElementById('deckPile'),
    deckCount: document.getElementById('deckCount'),
    trumpSuit: document.getElementById('trumpSuit'),
    discardCount: document.getElementById('discardCount'),
    opCount: document.getElementById('opCount'),
    log: document.getElementById('log'),
    newGameBtn: document.getElementById('newGameBtn'),
    endAttackBtn: document.getElementById('endAttackBtn'),
    takeBtn: document.getElementById('takeBtn'),
    turnBadge: document.getElementById('turnBadge'),
    statusBadge: document.getElementById('statusBadge'),
    playerScore: document.getElementById('playerScore'),
    aiScore: document.getElementById('aiScore'),
    resetScoreBtn: document.getElementById('resetScoreBtn'),
    peekBtn: document.getElementById('peekBtn'),
    swapBtn: document.getElementById('swapBtn'),
    superBadge: document.getElementById('superBadge'),
    transferModeChk: document.getElementById('transferModeChk'),
    doubleTrumpChk: document.getElementById('doubleTrumpChk'),
    transferNote: document.getElementById('transferNote'),
    trumpNote: document.getElementById('trumpNote'),
    rulesDetails: document.getElementById('rulesDetails'),
    endAttackBtn2: document.getElementById('endAttackBtn2'),
    takeBtn2: document.getElementById('takeBtn2'),
    fastBtn: document.getElementById('fastBtn')
  };

  // Helpers
  const sleep = (ms) => new Promise(res => setTimeout(res, ms));

  function makeDeck() {
    const deck = [];
    let id = 0;
    for (const s of SUITS) for (const r of RANKS) {
      deck.push({ id: id++, suit: s, rank: r, value: RANK_VALUE[r] });
    }
    return deck;
  }
  function shuffle(a) {
    for (let i = a.length -1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [a[i], a[j]] = [a[j], a[i]];
    }
    return a;
  }
  // Enforce rule: on initial deal, neither player may get 5+ cards of the same suit
  function hasFiveOrMoreSameSuit(cards) {
    const counts = { '♠': 0, '♥': 0, '♦': 0, '♣': 0 };
    for (const c of cards) counts[c.suit] = (counts[c.suit] || 0) + 1;
    return counts['♠'] >= 5 || counts['♥'] >= 5 || counts['♦'] >= 5 || counts['♣'] >= 5;
  }
  function violatesMonoSuitOnInitialDeal(preparedDeck) {
    // preparedDeck is the deck used for dealing (after reserving trump(s));
    // we simulate alternating pops: player, ai, player, ai ... (HAND_SIZE cards each)
    const tmp = preparedDeck.slice();
    const p = [];
    const a = [];
    for (let i = 0; i < HAND_SIZE; i++) {
      if (tmp.length === 0) break;
      p.push(tmp[tmp.length - 1]); tmp.pop();
      if (tmp.length === 0) break;
      a.push(tmp[tmp.length - 1]); tmp.pop();
    }
    return hasFiveOrMoreSameSuit(p) || hasFiveOrMoreSameSuit(a);
  }
  function prepareDeckForInitialDeal(maxAttempts = 300) {
    // Try multiple shuffles until initial hands do not violate the 5+ same-suit rule
    for (let attempt = 0; attempt < maxAttempts; attempt++) {
      const d = shuffle(makeDeck().slice());
      // Ensure face-up trump is not an Ace ('Т') by moving a non-Ace to index 0
      let idxTrump = d.findIndex(c => c.rank !== 'Т');
      if (idxTrump === -1) idxTrump = 0; // fallback, extremely unlikely
      if (idxTrump !== 0) {
        const tmp = d[0]; d[0] = d[idxTrump]; d[idxTrump] = tmp;
      }
      // If double-trump, ensure second trump is not an Ace either; position it at index 1
      let secondTrumpCard = null;
      if (state.doubleTrumpActive && d.length >= 2) {
        let idxSecond = d.findIndex((c, i) => i !== 0 && c.rank !== 'Т');
        if (idxSecond === -1) idxSecond = 1; // fallback if all Aces but one
        if (idxSecond !== 1) {
          const t2 = d[1]; d[1] = d[idxSecond]; d[idxSecond] = t2;
        }
        secondTrumpCard = d[1];
      }
      const trump = d[0];
      const working = d.slice();
      // Remove the hidden card from working deck so it won't be dealt
      if (secondTrumpCard) {
        working.splice(1, 1);
      }
      if (!violatesMonoSuitOnInitialDeal(working)) {
        return { deck: working, trump, secondTrumpCard };
      }
    }
    // Fallback (extremely unlikely): return last attempt even if violates
    const d = shuffle(makeDeck().slice());
    let idxTrump = d.findIndex(c => c.rank !== 'Т');
    if (idxTrump === -1) idxTrump = 0;
    if (idxTrump !== 0) { const tmp = d[0]; d[0] = d[idxTrump]; d[idxTrump] = tmp; }
    let secondTrumpCard = null;
    if (state.doubleTrumpActive && d.length >= 2) {
      let idxSecond = d.findIndex((c, i) => i !== 0 && c.rank !== 'Т');
      if (idxSecond === -1) idxSecond = 1;
      if (idxSecond !== 1) { const t2 = d[1]; d[1] = d[idxSecond]; d[idxSecond] = t2; }
      secondTrumpCard = d[1];
    }
    const trump = d[0];
    const working = d.slice();
    if (secondTrumpCard) working.splice(1, 1);
    return { deck: working, trump, secondTrumpCard };
  }
  function sortHand(hand) {
    return hand.sort((c1, c2) => {
      const t1 = (c1.suit === state.trumpSuit) ? 1 : 0;
      const t2 = (c2.suit === state.trumpSuit) ? 1 : 0;
      if (t1 !== t2) return t1 - t2;
      if (c1.suit !== c2.suit) return SUITS.indexOf(c1.suit) - SUITS.indexOf(c2.suit);
      return c1.value - c2.value;
    });
  }
  function removeFromHand(player, cardId) {
    const idx = player.hand.findIndex(c => c.id == cardId);
    if (idx >= 0) player.hand.splice(idx, 1);
  }
  function ranksOnTable() {
    const s = new Set();
    for (const p of state.tablePairs) {
      if (p.attack) s.add(p.attack.rank);
      if (p.defense) s.add(p.defense.rank);
    }
    return s;
  }
  function defendedCount() {
    return state.tablePairs.filter(p => p.defense != null).length;
  }
  function cardBeats(def, atk) {
    if (!def || !atk) return false;
    if (def.suit === atk.suit && def.value > atk.value) return true;
    if (def.suit === state.trumpSuit && atk.suit !== state.trumpSuit) return true;
    return false;
  }
  function allDefended() {
    return state.tablePairs.length > 0 && state.tablePairs.every(p => p.defense != null);
  }
  function tableHasUndefended() {
    return state.tablePairs.some(p => p.defense == null);
  }
  function clearToDiscard() {
    for (const p of state.tablePairs) {
      if (p.attack) {
        state.discard.push(p.attack);
        if (state.memory && state.memory.seenDiscardIds) state.memory.seenDiscardIds.add(p.attack.id);
      }
      if (p.defense) {
        state.discard.push(p.defense);
        if (state.memory && state.memory.seenDiscardIds) state.memory.seenDiscardIds.add(p.defense.id);
      }
    }
    state.tablePairs = [];
  }
  // Dynamic cap of pairs per bout:
  // - On the very first attack card of a bout: max 5
  // - Thereafter: allow adding up to the defender's initial hand for the bout,
  //   which equals defendedCount() + defender.hand.length at any moment
  //   (this matches the common rule «до последней карты защитника»)
  function getAddCap(defender) {
    const firstMove = state.tablePairs.length === 0;
    if (firstMove) {
      state.boutStartDefHand = defender.hand.length;
      return Math.min(5, HAND_SIZE);
    }
    const dynamicCap = defendedCount() + defender.hand.length;
    return Math.min(dynamicCap, HAND_SIZE);
  }
  function moveTableTo(defender) {
    for (const p of state.tablePairs) {
      if (p.attack) defender.hand.push(p.attack);
      if (p.defense) defender.hand.push(p.defense);
    }
    state.tablePairs = [];
    sortHand(defender.hand);
  }
  function canAddMore(defender) {
    return state.tablePairs.length < getAddCap(defender);
  }
  function isValidAttackCard(card, defender) {
    if (state.tablePairs.length === 0) return true;
    const ranks = ranksOnTable();
    if (!ranks.has(card.rank)) return false;
    return state.tablePairs.length < getAddCap(defender);
  }
  function validPlayerAttackCards() {
    const defender = state.attacker === 'player' ? state.ai : state.player;
    return state.player.hand.filter(c => isValidAttackCard(c, defender));
  }
  function validPlayerDefenseCards() {
    const target = state.tablePairs.find(p => !p.defense)?.attack;
    if (!target) return [];
    return state.player.hand.filter(c => cardBeats(c, target));
  }
  function validPlayerTransferCards() {
    if (!state.transferMode) return [];
    if (state.attacker !== 'ai') return [];
    if (defendedCount() > 0) return [];
    const target = state.tablePairs.find(p => !p.defense)?.attack;
    if (!target) return [];
    const newDef = state.ai; // после перевода защищаться будет ИИ
    const cap = getAddCap(newDef);
    const nextPairs = state.tablePairs.length + 1;
    if (nextPairs > cap) return [];
    // Исключаем карты, которые могут побить — чтобы не вызывать конфликт выбора
    return state.player.hand.filter(c => c.rank === target.rank && !cardBeats(c, target));
  }
  function chooseLowest(cards, preferNonTrump=true) {
    const hand = [...cards];
    hand.sort((a,b) => {
      const at = a.suit === state.trumpSuit ? 1 : 0;
      const bt = b.suit === state.trumpSuit ? 1 : 0;
      if (preferNonTrump && at !== bt) return at - bt;
      if (a.suit === b.suit) return a.value - b.value;
      return a.value - b.value;
    });
    return hand[0];
  }
  // Simple player advisor: suggests 1-2 best cards based on current phase
  function adviseBestPlayerCard() {
    if (!state.advisorOn) return null;
    const picks = new Set();
    if (state.attacker === 'player') {
      const defender = state.ai;
      const candidates = state.player.hand.filter(c => isValidAttackCard(c, defender));
      if (candidates.length > 0) {
        candidates.sort((a,b)=>{
          const at = a.suit === state.trumpSuit ? 1 : 0;
          const bt = b.suit === state.trumpSuit ? 1 : 0;
          if (at !== bt) return at - bt;
          return a.value - b.value;
        });
        picks.add(candidates[0].id);
        if (candidates[1]) picks.add(candidates[1].id);
      }
    } else {
      const target = state.tablePairs.find(p => !p.defense)?.attack;
      if (target) {
        const defenders = state.player.hand.filter(c => cardBeats(c, target));
        if (defenders.length > 0) {
          defenders.sort((a,b)=>{
            const at = a.suit === state.trumpSuit ? 1 : 0;
            const bt = b.suit === state.trumpSuit ? 1 : 0;
            if (at !== bt) return at - bt;
            return a.value - b.value;
          });
          picks.add(defenders[0].id);
          if (defenders[1]) picks.add(defenders[1].id);
        }
      }
    }
    return picks.size ? picks : null;
  }
  function updateAdvisorToast() {
    if (!state.advisorOn) return;
    if (state.attacker === 'player') {
      showToast('Подсказка: атакуйте низкой некозырной или рангом на стол.');
    } else {
      showToast('Подсказка: бейте минимальной подходящей картой или переведите.');
    }
  }
  function countRanksInHand(hand) {
    const map = new Map();
    for (const c of hand) map.set(c.rank, (map.get(c.rank) || 0) + 1);
    return map;
  }
  function aiChooseAttackCard() {
    const defender = state.player;
    const hand = state.ai.hand;
    const cap = getAddCap(defender);
    const ranks = ranksOnTable();
    const deckEmpty = state.deck.length === 0;
    let candidates;
    if (state.tablePairs.length === 0) {
      candidates = hand.slice();
    } else {
      if (state.tablePairs.length >= cap) return null;
      candidates = hand.filter(c => ranks.has(c.rank));
    }
    if (candidates.length === 0) return null;
    const dislikes = state.memory?.playerDislikeScore || { '♠':0,'♥':0,'♦':0,'♣':0 };
    const rankCounts = countRanksInHand(hand);
    candidates.sort((a, b) => {
      const at = a.suit === state.trumpSuit ? 1 : 0;
      const bt = b.suit === state.trumpSuit ? 1 : 0;
      if (at !== bt) return at - bt;
      if (deckEmpty) {
        const adup = (rankCounts.get(a.rank) || 0) >= 2 ? 0 : 1;
        const bdup = (rankCounts.get(b.rank) || 0) >= 2 ? 0 : 1;
        if (adup !== bdup) return adup - bdup;
      }
      const ad = -(dislikes[a.suit] || 0);
      const bd = -(dislikes[b.suit] || 0);
      if (ad !== bd) return ad - bd;
      if (a.value !== b.value) return a.value - b.value;
      return SUITS.indexOf(a.suit) - SUITS.indexOf(b.suit);
    });
    return candidates[0];
  }
  function aiChooseDefenseCard(attackCard) {
    const candidates = state.ai.hand.filter(c => cardBeats(c, attackCard));
    if (candidates.length === 0) return null;
    candidates.sort((a,b)=> {
      const at = a.suit === state.trumpSuit ? 1 : 0;
      const bt = b.suit === state.trumpSuit ? 1 : 0;
      if (at !== bt) return at - bt; // prefer non-trumps
      if (a.suit === b.suit) return a.value - b.value;
      return a.value - b.value;
    });
    return candidates[0];
  }
  // Оценка: способен ли ИИ побить все открытые атаки (без траты карт впустую)
  function aiCanDefendAllOpenPairs(aiHand, openAttacks) {
    const nA = openAttacks.length;
    if (nA === 0) return true;
    // Строим двудольный граф: атаки -> подходящие защитные карты ИИ
    const adj = openAttacks.map((atk) => aiHand
      .map((c, j) => ({ j, c }))
      .filter(x => cardBeats(x.c, atk))
      .map(x => x.j)
    );
    const matchToAttack = new Array(aiHand.length).fill(-1);
    function dfs(aIdx, seen) {
      for (const j of adj[aIdx]) {
        if (seen[j]) continue;
        seen[j] = true;
        if (matchToAttack[j] === -1 || dfs(matchToAttack[j], new Array(aiHand.length).fill(false))) {
          matchToAttack[j] = aIdx;
          return true;
        }
      }
      return false;
    }
    for (let i = 0; i < nA; i++) {
      if (!dfs(i, new Array(aiHand.length).fill(false))) return false;
    }
    return true;
  }
  async function aiDefendAllOpenOrTake() {
    // Предоценка: если ИИ не может закрыть все открытые атаки, то сразу берёт
    const openNow = state.tablePairs.filter(p => p.defense == null).map(p => p.attack);
    if (!aiCanDefendAllOpenPairs(state.ai.hand, openNow)) {
      const cap = getAddCap(state.ai);
      const left = Math.max(0, cap - state.tablePairs.length);
      const canPlayerAdd = validPlayerAttackCards().length > 0 && left > 0;
      if (canPlayerAdd) {
        setMessage(left > 0 ? `ИИ не может побить и берёт. Можете подкинуть ещё ${left} карт(ы) по рангу и затем нажмите «Завершить догонку».` : 'ИИ не может побить и берёт. Подкинуть уже нельзя. Нажмите «Завершить догонку».');
        state.phase = 'dogonka';
        updateUI();
        return;
      } else {
        setMessage('ИИ не может побить и берёт.');
        updateUI();
        await defenderTakes(state.ai);
        return;
      }
    }
    while (true) {
      const openPair = state.tablePairs.find(p => p.defense == null);
      if (!openPair) break;
      const defCard = aiChooseDefenseCard(openPair.attack);
      if (defCard) {
        removeFromHand(state.ai, defCard.id);
        openPair.defense = defCard;
        updateUI();
        await sleep(350);
      } else {
        const cap = getAddCap(state.ai);
        const left = Math.max(0, cap - state.tablePairs.length);
        const canPlayerAdd = validPlayerAttackCards().length > 0 && left > 0;
        if (canPlayerAdd) {
          setMessage(left > 0 ? `ИИ не может побить и берёт. Можете подкинуть ещё ${left} карт(ы) по рангу и затем нажмите «Завершить догонку».` : 'ИИ не может побить и берёт. Подкинуть уже нельзя. Нажмите «Завершить догонку».');
          state.phase = 'dogonka';
          updateUI();
          return;
        } else {
          setMessage('ИИ не может побить и берёт.');
          updateUI();
          await defenderTakes(state.ai);
          return;
        }
      }
    }
    setMessage('ИИ побил все карты. Можете подкинуть или завершить атаку (Бито).');
    updateUI();
  }
  function lowestTrumpIn(hand) {
    const trumps = hand.filter(c => c.suit === state.trumpSuit);
    if (trumps.length === 0) return null;
    trumps.sort((a,b)=> a.value - b.value);
    return trumps[0];
  }
  function determineFirstAttacker() {
    const pt = lowestTrumpIn(state.player.hand);
    const at = lowestTrumpIn(state.ai.hand);
    if (pt && at) {
      state.attacker = (pt.value < at.value) ? 'player' : 'ai';
    } else if (pt && !at) {
      state.attacker = 'player';
    } else if (!pt && at) {
      state.attacker = 'ai';
    } else {
      state.attacker = 'player';
    }
  }
  function setMessage(msg) {
    state.message = msg;
    el.log.innerHTML = msg;
  }
  function ensureToastContainer() {
    let c = document.getElementById('toastContainer');
    if (!c) {
      c = document.createElement('div');
      c.id = 'toastContainer';
      c.className = 'toast-container';
      document.body.appendChild(c);
    }
    return c;
  }
  function showToast(text, timeout=2200) {
    const c = ensureToastContainer();
    const t = document.createElement('div');
    t.className = 'toast';
    t.textContent = text;
    c.appendChild(t);
    setTimeout(()=>{
      t.style.transition = 'opacity 0.3s ease, transform 0.3s ease';
      t.style.opacity = '0';
      t.style.transform = 'translateY(-6px)';
      setTimeout(()=> t.remove(), 320);
    }, timeout);
  }

  // Persistence (cookies)
  function setCookie(name, value, days=365) {
    const d = new Date();
    d.setTime(d.getTime() + (days*24*60*60*1000));
    const expires = 'expires=' + d.toUTCString();
    document.cookie = name + '=' + encodeURIComponent(value) + ';' + expires + ';path=/';
  }
  function getCookie(name) {
    const cname = name + '=';
    const decoded = document.cookie;
    const arr = decoded.split(';');
    for (let c of arr) {
      c = c.trim();
      if (c.indexOf(cname) === 0) return decodeURIComponent(c.substring(cname.length, c.length));
    }
    return null;
  }
  function persistState() {
    try {
      const payload = {
        deck: state.deck,
        discard: state.discard,
        tablePairs: state.tablePairs,
        trumpSuit: state.trumpSuit,
        trumpRefRank: state.trumpRefRank,
        prevTrumpSuit: state.prevTrumpSuit,
        prevTrumpRefRank: state.prevTrumpRefRank,
        doubleTrumpActive: state.doubleTrumpActive,
        doubleTrumpPlanned: state.doubleTrumpPlanned,
        secondTrumpCard: state.secondTrumpCard,
        secondTrumpRevealed: state.secondTrumpRevealed,
        player: state.player,
        ai: state.ai,
        attacker: state.attacker,
        phase: state.phase,
        message: state.message,
        gameOver: state.gameOver,
        playerScore: state.playerScore,
        aiScore: state.aiScore,
        superUsed: state.superUsed,
        peekActive: state.peekActive,
        transferMode: state.transferMode,
        transferModePlanned: state.transferModePlanned,
        fastDeal: state.fastDeal,
        // dealing-resume fields
        isDealing: state.isDealing,
        dealContext: state.dealContext,
        dealAttackerFirst: state.dealAttackerFirst,
        postDeal: state.postDeal,
        // UI prefs
        zoomScale: typeof zoomScale === 'number' ? zoomScale : 1.0
      };
      // Store into localStorage (primary) and cookie as a graceful fallback
      localStorage.setItem('durak_state', JSON.stringify(payload));
      setCookie('durak_state', JSON.stringify(payload));
    } catch(e) { /* ignore */ }
  }
  function tryRestoreState() {
    try {
      const raw = localStorage.getItem('durak_state') || getCookie('durak_state');
      if (!raw) return false;
      const saved = JSON.parse(raw);
      // shallow restore primitives and arrays
      state.deck = saved.deck || [];
      state.discard = saved.discard || [];
      state.tablePairs = saved.tablePairs || [];
      state.trumpSuit = saved.trumpSuit || null;
      state.trumpRefRank = saved.trumpRefRank || null;
      state.prevTrumpSuit = saved.prevTrumpSuit || null;
      state.prevTrumpRefRank = saved.prevTrumpRefRank || null;
      if (saved.doubleTrumpActive !== undefined || saved.doubleTrumpPlanned !== undefined) {
        state.doubleTrumpActive = !!saved.doubleTrumpActive;
        state.doubleTrumpPlanned = !!saved.doubleTrumpPlanned;
      } else if (saved.doubleTrumpMode !== undefined) {
        // backward compatibility
        state.doubleTrumpActive = !!saved.doubleTrumpMode;
        state.doubleTrumpPlanned = !!saved.doubleTrumpMode;
      }
      state.secondTrumpCard = saved.secondTrumpCard || null;
      state.secondTrumpRevealed = !!saved.secondTrumpRevealed;
      state.player = saved.player || { hand: [], name: 'Игрок' };
      state.ai = saved.ai || { hand: [], name: 'ИИ' };
      state.attacker = saved.attacker || 'player';
      state.phase = saved.phase || 'idle';
      state.message = saved.message || '';
      state.gameOver = !!saved.gameOver;
      state.playerScore = saved.playerScore || 0;
      state.aiScore = saved.aiScore || 0;
      state.superUsed = !!saved.superUsed;
      state.peekActive = !!saved.peekActive;
      state.transferMode = !!saved.transferMode;
      state.transferModePlanned = !!saved.transferModePlanned;
      state.fastDeal = !!saved.fastDeal;
      // UI prefs
      if (saved.zoomScale !== undefined && typeof saved.zoomScale === 'number') {
        zoomScale = Math.max(0.6, Math.min(1.4, saved.zoomScale));
        applyZoom(zoomScale);
      }
      // dealing-resume fields
      state.isDealing = !!saved.isDealing;
      state.dealContext = saved.dealContext || null;
      state.dealAttackerFirst = saved.dealAttackerFirst !== undefined ? !!saved.dealAttackerFirst : true;
      state.postDeal = saved.postDeal || null;
      // ensure hands are sorted under current trump
      sortHand(state.player.hand);
      sortHand(state.ai.hand);
      return true;
    } catch(e) { return false; }
  }
  function setBadges() {
    el.turnBadge.textContent = 'Ходит: ' + (state.attacker === 'player' ? 'Вы' : 'ИИ');
    let phaseTitle = '';
    switch (state.phase) {
      case 'attack': phaseTitle = 'Атака'; break;
      case 'defense': phaseTitle = 'Защита'; break;
      case 'adding': phaseTitle = 'Подкидка'; break;
      case 'ai_turn': phaseTitle = 'Ход ИИ'; break;
      case 'between': phaseTitle = 'Меж ходами'; break;
      default: phaseTitle = '—';
    }
    el.statusBadge.textContent = 'Статус: ' + phaseTitle;
    el.superBadge.textContent = 'Суперсила: ' + (state.superUsed ? 'использована' : 'доступна');
    // Trump badge: highlight when double-trump mode is ON; flash once on reveal
    const badgeWrapper = document.querySelector('.trump-badge');
    if (badgeWrapper) {
      badgeWrapper.classList.toggle('double-on', !!state.doubleTrumpActive);
      if (state.secondTrumpRevealed && !badgeWrapper.classList.contains('flash')) {
        badgeWrapper.classList.add('flash');
      }
    }
  }
  function updateScoreBoard() {
    el.playerScore.textContent = state.playerScore;
    el.aiScore.textContent = state.aiScore;
  }

  // Rendering
  function renderCard(c, faceUp=true) {
    const d = document.createElement('div');
    d.className = 'card';
    if (!faceUp) {
      d.classList.add('face-down');
      return d;
    }
    if (c && RED_SUITS.has(c.suit)) d.classList.add('red');
    const r = document.createElement('div');
    r.className = 'rank';
    r.textContent = c ? c.rank : '';
    const s = document.createElement('div');
    s.className = 'suit';
    s.textContent = c ? c.suit : '';
    const sr = document.createElement('div');
    sr.className = 'corner-rank';
    sr.textContent = c ? c.rank : '';
    const ss = document.createElement('div');
    ss.className = 'small-suit';
    ss.textContent = c ? c.suit : '';
    d.appendChild(r); d.appendChild(s); d.appendChild(sr); d.appendChild(ss);
    return d;
  }
  function renderHands() {
    // Player
    el.playerHand.innerHTML = '';
    const defender = state.attacker === 'player' ? state.ai : state.player;

    const validAtk = (state.attacker === 'player') ? new Set(validPlayerAttackCards().map(c=>c.id)) : new Set();
    const validDef = (state.attacker === 'ai' && tableHasUndefended()) ? new Set(validPlayerDefenseCards().map(c=>c.id)) : new Set();
    const validTransfer = new Set(validPlayerTransferCards().map(c=>c.id));

    state.player.hand.forEach((c) => {
      const cardEl = renderCard(c, true);
      cardEl.dataset.id = c.id;
      if (!state.isDealing && !state.gameOver) {
        cardEl.classList.add('clickable');
        if (state.attacker === 'player' && isValidAttackCard(c, defender)) {
          cardEl.classList.add('valid');
          cardEl.title = 'Кликните чтобы атаковать';
        }
        if (state.attacker === 'ai' && validDef.has(c.id)) {
          cardEl.classList.add('valid');
          cardEl.title = 'Кликните чтобы побить';
        }
        if (state.attacker === 'ai' && validTransfer.has(c.id)) {
          cardEl.classList.add('transfer');
          cardEl.title = 'Перевести (карта того же ранга)';
        }
        // Advisor highlighting
        if (state.advisorOn) {
          const advice = adviseBestPlayerCard();
          if (advice && advice.has(c.id)) cardEl.classList.add('advice');
        }
        cardEl.addEventListener('click', () => onPlayerCardClick(c.id));
      }
      el.playerHand.appendChild(cardEl);
    });

    // Opponent
    el.opHand.innerHTML = '';
    const opCount = state.ai.hand.length;
    el.opCount.textContent = opCount;
    if (state.peekActive) {
      // Show real opponent cards face-up temporarily
      state.ai.hand.forEach(c => {
        const face = renderCard(c, true);
        el.opHand.appendChild(face);
      });
    } else {
      const maxShow = Math.min(12, opCount);
      for (let i=0; i<maxShow; i++) {
        const back = renderCard(null, false);
        back.style.transform = '';
        el.opHand.appendChild(back);
      }
    }
    // ensure ends are visible on mobile by padding shadows
    el.playerHand.style.scrollPaddingLeft = '16px';
    el.playerHand.style.scrollPaddingRight = '16px';
  }
  function renderTable() {
    el.pairs.innerHTML = '';
    for (const p of state.tablePairs) {
      const pairEl = document.createElement('div');
      pairEl.className = 'pair' + (p.defense==null ? ' open' : '');
      if (p.attack) {
        const a = renderCard(p.attack, true);
        a.classList.add('attack');
        pairEl.appendChild(a);
      }
      if (p.defense) {
        const d = renderCard(p.defense, true);
        d.classList.add('defense');
        pairEl.appendChild(d);
      }
      el.pairs.appendChild(pairEl);
    }
  }
  function renderDeck() {
    el.deckPile.innerHTML = '';
    if (state.deck.length > 0) {
      const n = Math.min(3, state.deck.length);
      for (let i=0;i<n;i++) {
        const back = renderCard(null, false);
        back.style.transform = `translate(${i*2}px, ${-i*2}px)`;
        el.deckPile.appendChild(back);
      }
      const trumpRef = { suit: state.trumpSuit, rank: state.trumpRefRank || '6', value: RANK_VALUE[state.trumpRefRank || '6'] };
      // If double-trump mode is active and second trump is not revealed yet, show a hidden card under the trump (face-down)
      if (state.doubleTrumpActive && !state.secondTrumpRevealed) {
        const hidden = renderCard(null, false);
        hidden.classList.add('hidden-under-trump');
        hidden.style.transform = 'rotate(90deg) translate(8px, 16px)';
        hidden.style.opacity = '0.95';
        el.deckPile.appendChild(hidden);
      }
      const t = renderCard(trumpRef, true);
      t.style.transform = 'rotate(90deg) translate(16px, 26px)';
      el.deckPile.appendChild(t);
    }
    el.deckCount.textContent = state.deck.length;
    el.trumpSuit.textContent = (state.doubleTrumpActive && state.secondTrumpRevealed && state.prevTrumpSuit && state.prevTrumpRefRank)
      ? `${state.trumpSuit || '—'} (был ${state.prevTrumpRefRank}${state.prevTrumpSuit})`
      : (state.trumpSuit || '—');
    el.discardCount.textContent = state.discard.length;
  }
  function updateButtons() {
    const noClicks = state.isDealing || state.gameOver;
    const canFinishDogonka = state.attacker === 'player' && state.phase === 'dogonka' && state.tablePairs.length > 0;
    const endText = (state.phase === 'dogonka') ? 'Завершить догонку' : 'Бито';
    const endDisabled = noClicks || !(state.attacker === 'player' && state.tablePairs.length > 0 && (allDefended() || canFinishDogonka));
    const takeDisabled = noClicks || !(state.attacker === 'ai' && state.tablePairs.length > 0 && tableHasUndefended());
    if (el.endAttackBtn2) { el.endAttackBtn2.textContent = endText; el.endAttackBtn2.disabled = endDisabled; }
    if (el.takeBtn2) { el.takeBtn2.disabled = takeDisabled; }
    if (el.endAttackBtn) { el.endAttackBtn.textContent = endText; el.endAttackBtn.disabled = endDisabled; }
    if (el.takeBtn) { el.takeBtn.disabled = takeDisabled; }
    if (el.peekBtn) el.peekBtn.disabled = noClicks || state.superUsed;
    if (el.swapBtn) el.swapBtn.disabled = noClicks || state.superUsed || state.player.hand.length === 0;
    // Shuffle button visible only during dealing
    if (el.mashBtn) el.mashBtn.style.display = state.isDealing && !state.gameOver ? '' : 'none';
  }
  function updateModeNotes() {
    if (el.transferNote) el.transferNote.textContent = state.transferModePlanned ? ' (сл. раунд)' : '';
    if (el.trumpNote) el.trumpNote.textContent = state.doubleTrumpPlanned ? ' (сл. раунд)' : '';
  }
  // Zoom helpers
  function applyZoom(scale) {
    const minW = 48, minH = 72, maxW = 110, maxH = 165;
    const w = Math.max(minW, Math.min(maxW, Math.round(80 * scale)));
    const h = Math.max(minH, Math.min(maxH, Math.round(120 * scale)));
    document.documentElement.style.setProperty('--card-w', w + 'px');
    document.documentElement.style.setProperty('--card-h', h + 'px');
  }
  // Auto layout for mobile: when too many cards or many pairs on table, switch to two rows or auto-zoom
  function autoLayoutForMobile() {
    const isMobile = window.matchMedia('(max-width: 768px)').matches;
    if (!isMobile) { el.playerHand.classList.remove('two-rows'); return; }
    const handCount = state.player.hand.length;
    const tableLoad = state.tablePairs.length; // many cards on table
    // If hand is big or table has many pairs, try two rows; if still overflowing, reduce zoom slightly
    const handEl = el.playerHand;
    // Toggle two-rows when hand >= 10 or table pairs >= 6
    if (handCount >= 10 || tableLoad >= 6) {
      handEl.classList.add('two-rows');
    } else {
      handEl.classList.remove('two-rows');
    }
    // Simple auto-shrink: ensure total visible height fits under available area
    try {
      const area = document.querySelector('.player-area');
      if (!area) return;
      const areaRect = area.getBoundingClientRect();
      const tableRect = document.querySelector('.center-area').getBoundingClientRect();
      const overlap = (tableRect.bottom + 8) - areaRect.top;
      if (overlap > 0) {
        // reduce zoom in small steps, down to minScale
        const desired = Math.max(0.6, zoomScale - 0.1);
        if (desired < zoomScale) { zoomScale = desired; applyZoom(zoomScale); }
      }
    } catch(_) { /* ignore */ }
  }
  function updateUI() {
    el.tableRoot.classList.toggle('busy', state.isDealing);
    // Reveal second trump if enabled and deck is empty
    maybeRevealSecondTrump();
    // Sync mode toggles from state
    if (el.transferModeChk) el.transferModeChk.checked = !!state.transferModePlanned;
    if (el.doubleTrumpChk) el.doubleTrumpChk.checked = !!state.doubleTrumpPlanned;
    updateModeNotes();
    // Restore message into log on redraw
    if (el.log && typeof state.message === 'string' && state.message.length > 0) {
      el.log.innerHTML = state.message;
    }
    setBadges();
    updateScoreBoard();
    renderDeck();
    renderTable();
    renderHands();
    updateButtons();
    autoLayoutForMobile();
    updateAdvisorToast();
    persistState();
  }

  // Animations
  async function animateShuffle() {
    // Show deck, shake it
    renderDeck();
    const deckEl = el.deckPile;
    const steps = 14;
    for (let i=0; i<steps; i++) {
      const dx = (Math.random() - 0.5) * 14;
      const dy = (Math.random() - 0.5) * 10;
      const rot = (Math.random() - 0.5) * 14;
      deckEl.style.transition = 'transform 0.06s ease';
      deckEl.style.transform = `translate(${dx}px, ${dy}px) rotate(${rot}deg)`;
      await sleep(60);
    }
    deckEl.style.transition = 'transform 0.15s ease';
    deckEl.style.transform = `translate(0,0) rotate(0deg)`;
    await sleep(150);
  }
  function createFlyingCardEl(faceUp, card) {
    const elCard = document.createElement('div');
    elCard.className = 'flying-card card' + (faceUp ? '' : ' face-down');
    if (faceUp && card) {
      if (RED_SUITS.has(card.suit)) elCard.classList.add('red');
      const r = document.createElement('div'); r.className = 'rank'; r.textContent = card.rank;
      const s = document.createElement('div'); s.className = 'suit'; s.textContent = card.suit;
      const sr = document.createElement('div'); sr.className = 'corner-rank'; sr.textContent = card.rank;
      const ss = document.createElement('div'); ss.className = 'small-suit'; ss.textContent = card.suit;
      elCard.appendChild(r); elCard.appendChild(s); elCard.appendChild(sr); elCard.appendChild(ss);
    }
    return elCard;
  }
  function getCenterRect(node) {
    const r = node.getBoundingClientRect();
    return { cx: r.left + r.width/2, cy: r.top + r.height/2, w: r.width, h: r.height, l: r.left, t: r.top };
  }
  async function animateDealOne(toWho) {
    if (state.deck.length === 0) return false;
    const card = state.deck.pop();
    const faceUp = (toWho === state.player);
    const fly = createFlyingCardEl(faceUp, card);

    const deckRect = getCenterRect(el.deckPile);
    const startX = deckRect.cx - (parseInt(getComputedStyle(document.documentElement).getPropertyValue('--card-w'))/2);
    const startY = deckRect.cy - (parseInt(getComputedStyle(document.documentElement).getPropertyValue('--card-h'))/2);
    fly.style.left = `${startX}px`; fly.style.top = `${startY}px`; fly.style.transform = `translate(0px,0px)`;
    document.body.appendChild(fly);

    updateUI();
    const handEl = (toWho === state.player) ? el.playerHand : el.opHand;
    const handRect = getCenterRect(handEl);
    const dx = handRect.cx - startX - (parseInt(getComputedStyle(document.documentElement).getPropertyValue('--card-w'))/2);
    const dy = handRect.cy - startY - (parseInt(getComputedStyle(document.documentElement).getPropertyValue('--card-h'))/2);

    await sleep(state.fastDeal ? 0 : 10);
    fly.style.transform = `translate(${dx}px, ${dy}px)`;
    await new Promise(resolve => fly.addEventListener('transitionend', resolve, { once: true }));

    toWho.hand.push(card);
    sortHand(toWho.hand);
    fly.remove();
    updateUI();
    await sleep(state.fastDeal ? 0 : 60);
    return true;
  }

  // Animation: reveal second trump with flip and fly to player hand (visual only)
  async function animateRevealSecondTrump(card) {
    state.revealAnimating = true;
    // create card at deck trump position
    const deckRect = getCenterRect(el.deckPile);
    const startX = deckRect.cx - (parseInt(getComputedStyle(document.documentElement).getPropertyValue('--card-w'))/2);
    const startY = deckRect.cy - (parseInt(getComputedStyle(document.documentElement).getPropertyValue('--card-h'))/2);
    const fly = createFlyingCardEl(true, card);
    fly.style.left = `${startX}px`;
    fly.style.top = `${startY}px`;
    fly.style.transform = 'rotate(90deg) translate(12px, 18px)';
    fly.style.transition = 'transform 0.28s ease, opacity 0.28s ease';
    fly.style.transformOrigin = 'center center';
    document.body.appendChild(fly);

    // initial flip-in place
    await sleep(10);
    fly.style.transform = 'rotate(0deg) translate(0px, 0px) scale(1)';
    await new Promise(resolve => fly.addEventListener('transitionend', resolve, { once: true }));

    // fly towards player hand center
    const handEl = el.playerHand;
    const handRect = getCenterRect(handEl);
    const dx = handRect.cx - startX - (parseInt(getComputedStyle(document.documentElement).getPropertyValue('--card-w'))/2);
    const dy = handRect.cy - startY - (parseInt(getComputedStyle(document.documentElement).getPropertyValue('--card-h'))/2);
    await sleep(10);
    fly.style.transform = `translate(${dx}px, ${dy}px) rotate(6deg)`;
    fly.style.opacity = '0.9';
    await new Promise(resolve => fly.addEventListener('transitionend', resolve, { once: true }));

    // fade out near hand (not adding to hand logically)
    fly.style.transition = 'opacity 0.18s ease, transform 0.18s ease';
    fly.style.opacity = '0';
    fly.style.transform += ' scale(0.96)';
    await new Promise(resolve => setTimeout(resolve, 190));
    fly.remove();
    state.revealAnimating = false;
  }
  async function initialDealAnimated() {
    state.isDealing = true;
    state.dealContext = 'initial';
    updateUI();
    // Resume-aware alternating deal: always give the next card to the one у кого меньше карт
    while (state.player.hand.length < HAND_SIZE || state.ai.hand.length < HAND_SIZE) {
      if (state.deck.length === 0) break;
      const giveToPlayer = state.player.hand.length === state.ai.hand.length;
      const target = giveToPlayer ? state.player : state.ai;
      if ((giveToPlayer && state.player.hand.length >= HAND_SIZE) || (!giveToPlayer && state.ai.hand.length >= HAND_SIZE)) {
        // If chosen target already full, give to the other if needed
        const altTarget = giveToPlayer ? state.ai : state.player;
        if ((giveToPlayer && state.ai.hand.length < HAND_SIZE) || (!giveToPlayer && state.player.hand.length < HAND_SIZE)) {
          await animateDealOne(altTarget);
        } else {
          break;
        }
      } else {
        await animateDealOne(target);
      }
    }
    state.isDealing = false;
    state.dealContext = null;
    updateUI();
  }
  async function drawUpToSixAnimated(attackerFirst = true) {
    state.isDealing = true;
    state.dealContext = 'refill';
    state.dealAttackerFirst = attackerFirst;
    updateUI();
    const atk = state.attacker === 'player' ? state.player : state.ai;
    const def = state.attacker === 'player' ? state.ai : state.player;

    async function drawTo(target, n) {
      const missing = Math.max(0, n);
      const already = Math.max(0, target.hand.length);
      // We just draw n cards, but target.hand could already be partially refilled before reload
      let toDraw = missing;
      for (let i = 0; i < toDraw; i++) {
        if (state.deck.length === 0) break;
        await animateDealOne(target);
      }
    }
    const needA = Math.max(0, HAND_SIZE - atk.hand.length);
    const needD = Math.max(0, HAND_SIZE - def.hand.length);
    if (attackerFirst) { await drawTo(atk, needA); await drawTo(def, needD); }
    else { await drawTo(def, needD); await drawTo(atk, needA); }

    state.isDealing = false;
    state.dealContext = null;
    updateUI();
  }

  // Turn flow and game logic
  function checkGameOver() {
    if (state.deck.length === 0) {
      const pEmpty = state.player.hand.length === 0;
      const aEmpty = state.ai.hand.length === 0;
      if (pEmpty && aEmpty) {
        setMessage('Ничья: карты закончились у обоих.');
        state.gameOver = true; updateUI(); return true;
      }
      if (pEmpty) {
        state.playerScore++;
        setMessage('Победа! Вы вышли из карт первым. Счет: Вы ' + state.playerScore + ' — ИИ ' + state.aiScore);
        celebrate();
        // В конце раунда (ваша победа) — вскрыть все карты ИИ до новой игры
        state.peekActive = true;
        state.gameOver = true; updateUI(); return true;
      }
      if (aEmpty) {
        state.aiScore++;
        setMessage('ИИ вышел из карт, вы остались с картами. Раунд за ИИ. Счет: Вы ' + state.playerScore + ' — ИИ ' + state.aiScore);
        state.gameOver = true; updateUI(); return true;
      }
    }
    return false;
  }
  function celebrate() {
    const colors = ['#ff6b6b','#ffd166','#06d6a0','#118ab2','#c77dff'];
    const num = 80;
    for (let i=0;i<num;i++) {
      const piece = document.createElement('div');
      piece.className = 'confetti';
      piece.style.background = colors[Math.floor(Math.random()*colors.length)];
      piece.style.left = (window.innerWidth*0.2 + Math.random()*window.innerWidth*0.6) + 'px';
      piece.style.top = '-20px';
      piece.style.transform = `rotate(${Math.random()*360}deg)`;
      document.body.appendChild(piece);
      const dx = (Math.random()-0.5)*120;
      const dy = window.innerHeight + Math.random()*200;
      const rot = (Math.random()-0.5)*360;
      piece.animate([
        { transform: piece.style.transform, opacity: 1 },
        { transform: `translate(${dx}px, ${dy}px) rotate(${rot}deg)`, opacity: 0.8 }
      ], { duration: 1600 + Math.random()*800, easing: 'ease-out', fill: 'forwards' });
      setTimeout(()=> piece.remove(), 2500);
    }
    showToast('Победа! 🎉');
  }

  async function endBoutSuccessfulDefense() {
    clearToDiscard();
    updateUI();
    await drawUpToSixAnimated(true);
    state.boutStartDefHand = null;
    state.attacker = (state.attacker === 'player') ? 'ai' : 'player';
    state.phase = (state.attacker === 'player') ? 'attack' : 'ai_turn';
    updateUI();
    if (checkGameOver()) return;
    setMessage(state.attacker === 'player' ? 'Ваш ход: атакуйте.' : 'Ход ИИ: ожидайте.');
    if (state.attacker === 'ai') setTimeout(aiTurn, 500);
  }

  async function defenderTakes(defender) {
    moveTableTo(defender);
    updateUI();
    await drawUpToSixAnimated(true);
    state.boutStartDefHand = null;
    state.phase = (state.attacker === 'player') ? 'attack' : 'ai_turn';
    updateUI();
    if (checkGameOver()) return;
    setMessage(defender === state.ai ? 'Противник взял. Ваш ход продолжается.' : 'Вы взяли. ИИ атакует снова.');
    if (state.attacker === 'ai') setTimeout(aiTurn, 600);
  }

  async function startGame() {
    if (state.isDealing) return;
    // Apply planned double-trump setting to this round and reset previous trump markers
    state.doubleTrumpActive = !!state.doubleTrumpPlanned;
    // Apply planned transfer mode setting to this round
    state.transferMode = !!state.transferModePlanned;
    state.prevTrumpSuit = null;
    state.prevTrumpRefRank = null;
    // Prepare deck and trump with redeal rule applied
    const prep = prepareDeckForInitialDeal();
    state.deck = prep.deck;
    const trumpCard = prep.trump;
    state.trumpSuit = trumpCard.suit;
    state.trumpRefRank = trumpCard.rank;

    // Double trump prep
    state.secondTrumpCard = prep.secondTrumpCard || null;
    state.secondTrumpRevealed = false;

    state.discard = [];
    state.tablePairs = [];
    state.player.hand = [];
    state.ai.hand = [];
    state.gameOver = false;

    // reset supers for new game
    state.superUsed = false;
    state.peekActive = false;
    state.memory.playerDislikeScore = { '♠': 0, '♥': 0, '♦': 0, '♣': 0 };
    state.memory.seenDiscardIds = new Set();
    state.boutStartDefHand = null;

    state.phase = 'between';
    setMessage('Перемешиваем колоду...');
    updateUI();
    await animateShuffle();

    setMessage('Раздача карт...');
    renderDeck();
    await initialDealAnimated();

    determineFirstAttacker();
    state.phase = (state.attacker === 'player') ? 'attack' : 'ai_turn';
    setMessage(state.attacker === 'player' ? 'Ваш ход: сыграйте любую карту для атаки.' : 'Ход ИИ: ожидайте.');
    updateUI();

    if (state.attacker === 'ai') setTimeout(aiTurn, 600);
  }

  // Double trump: reveal hidden trump and replace the suit when deck empties
  function maybeRevealSecondTrump() {
    if (!state.doubleTrumpActive) return;
    if (state.secondTrumpRevealed) return;
    if (state.deck.length === 0 && state.secondTrumpCard) {
      // Save previous trump to display
      state.prevTrumpSuit = state.trumpSuit;
      state.prevTrumpRefRank = state.trumpRefRank;
      // Switch trump to the hidden card
      state.trumpSuit = state.secondTrumpCard.suit;
      state.trumpRefRank = state.secondTrumpCard.rank;
      state.secondTrumpRevealed = true;
      // Animated reveal
      animateRevealSecondTrump(state.secondTrumpCard).catch(()=>{});
      showToast(`Вскрыт второй козырь: ${state.trumpRefRank}${state.trumpSuit} (был ${state.prevTrumpRefRank}${state.prevTrumpSuit})`);
      // Re-sort hands to reflect new trump priority
      sortHand(state.player.hand);
      sortHand(state.ai.hand);
    }
  }

  // Transfer logic helpers
  function canPlayerTransferWith(card) {
    if (!state.transferMode) return false;
    if (state.attacker !== 'ai') return false;
    if (defendedCount() > 0) return false;
    const target = state.tablePairs.find(p => !p.defense)?.attack;
    if (!target) return false;
    if (card.rank !== target.rank) return false;
    const newDef = state.ai;
    const cap = getAddCap(newDef);
    const nextPairs = state.tablePairs.length + 1;
    return nextPairs <= cap;
  }

  function aiCanTransferWithCard(card, attackCard) {
    if (!state.transferMode) return false;
    if (state.attacker !== 'player') return false; // AI is defender
    if (defendedCount() > 0) return false;
    if (!attackCard) return false;
    if (card.rank !== attackCard.rank) return false;
    const newDef = state.player;
    const cap = getAddCap(newDef);
    const nextPairs = state.tablePairs.length + 1;
    return nextPairs <= cap;
  }

  function onPlayerCardClick(cardId) {
    if (state.gameOver || state.isDealing) return;
    const card = state.player.hand.find(c => c.id == cardId);
    if (!card) return;

    if (state.attacker === 'player') {
      // Player attacking or adding
      const defender = state.ai;
      if (!isValidAttackCard(card, defender)) {
        setMessage('Этой картой сейчас подкидывать нельзя.');
        return;
      }
      // Play attack
      removeFromHand(state.player, cardId);
      state.tablePairs.push({ attack: card, defense: null });
      updateUI();

      // AI tries to defend (or transfer if allowed)
      setTimeout(() => {
        const pair = state.tablePairs.find(p => p.attack.id === cardId);
        // Try transfer first (переводной)
        if (state.transferMode && defendedCount() === 0) {
          const transferCand = state.ai.hand.find(c => aiCanTransferWithCard(c, pair.attack));
          if (transferCand) {
            removeFromHand(state.ai, transferCand.id);
            state.tablePairs.push({ attack: transferCand, defense: null });
            // Roles swap: AI becomes attacker
            state.attacker = 'ai';
            state.phase = 'ai_turn';
            setMessage('ИИ перевел! Теперь вы защищаетесь.');
            updateUI();
            return;
          }
        }

        // Otherwise, before defending, оценим: сможет ли ИИ побить все открытые атаки
        const openNow = state.tablePairs.filter(p => p.defense == null).map(p => p.attack);
        if (!aiCanDefendAllOpenPairs(state.ai.hand, openNow)) {
          const cap = getAddCap(state.ai);
          const left = Math.max(0, cap - state.tablePairs.length);
          const canPlayerAdd = validPlayerAttackCards().length > 0 && left > 0;
          if (canPlayerAdd) {
            setMessage(left > 0 ? `ИИ не может побить и берёт. Можете подкинуть ещё ${left} карт(ы) по рангу и затем нажмите «Завершить догонку».` : 'ИИ не может побить и берёт. Подкинуть уже нельзя. Нажмите «Завершить догонку».');
            state.phase = 'dogonka';
            updateUI();
            return;
          } else {
            setMessage('ИИ не может побить и берёт.');
            updateUI();
            setTimeout(async () => { await defenderTakes(state.ai); }, 200);
            return;
          }
        }

        // Otherwise defend
        const defCard = aiChooseDefenseCard(pair.attack);
        if (defCard) {
          removeFromHand(state.ai, defCard.id);
          pair.defense = defCard;
          setMessage('ИИ побил карту. Можете подкинуть по рангу на стол или завершить атаку (Бито).');
          updateUI();
        } else {
          const cap = getAddCap(state.ai);
          const left = Math.max(0, cap - state.tablePairs.length);
          const canPlayerAdd = validPlayerAttackCards().length > 0 && left > 0;
          if (canPlayerAdd) {
            setMessage(left > 0 ? `ИИ не может побить и берёт. Можете подкинуть ещё ${left} карт(ы) по рангу и затем нажмите «Завершить догонку».` : 'ИИ не может побить и берёт. Подкинуть уже нельзя. Нажмите «Завершить догонку».');
            state.phase = 'dogonka';
            updateUI();
            return;
          } else {
            setMessage('ИИ не может побить и берёт.');
            updateUI();
            setTimeout(async () => { await defenderTakes(state.ai); }, 200);
            return;
          }
        }
      }, 380);

    } else {
      // Player defending OR transferring
      const target = state.tablePairs.find(p => p.defense == null)?.attack;
      if (!target) { setMessage('Нет карт для побития.'); return; }

      // If transfer mode and card can transfer — ask player if card also beats
      if (canPlayerTransferWith(card)) {
        const target = state.tablePairs.find(p => p.defense == null)?.attack;
        const canBeat = cardBeats(card, target);
        if (canBeat) {
          // Offer choice: defend or transfer
          const choice = window.confirm('Этой картой можно побить или перевести. ОК — побить, Отмена — перевести.');
          if (choice) {
            // defend path
            if (!cardBeats(card, target)) { setMessage('Этой картой побить нельзя.'); return; }
            removeFromHand(state.player, cardId);
            const pair = state.tablePairs.find(p => p.attack.id === target.id);
            pair.defense = card;
            updateUI();
            if (allDefended()) { setTimeout(() => { aiMaybeAddMore(); }, 420); }
            return;
          }
        }
        removeFromHand(state.player, cardId);
        state.tablePairs.push({ attack: card, defense: null });
        // Roles swap: player becomes attacker
        state.attacker = 'player';
        state.phase = 'attack';
        updateUI();

        // After transfer, AI (new defender) must defend all or take
        setTimeout(async () => { await aiDefendAllOpenOrTake(); }, 380);
        return;
      }

      // Otherwise, normal defense
      if (!cardBeats(card, target)) {
        setMessage('Этой картой побить нельзя.');
        return;
      }
      removeFromHand(state.player, cardId);
      const pair = state.tablePairs.find(p => p.attack.id === target.id);
      pair.defense = card;
      updateUI();

      // After defending, AI may add if possible (step-by-step)
      if (allDefended()) {
        setTimeout(() => { aiMaybeAddMore(); }, 420);
      }
    }
  }

  function aiTurn() {
    if (state.gameOver || state.isDealing) return;
    if (state.attacker !== 'ai') return;

    if (state.tablePairs.length === 0 || allDefended()) {
      const card = aiChooseAttackCard();
      if (!card) {
        setMessage('ИИ завершил атаку: Бито.');
        endBoutSuccessfulDefense();
        return;
      }
      removeFromHand(state.ai, card.id);
      state.tablePairs.push({ attack: card, defense: null });
      setMessage('ИИ атакует. Побейте карту, переведите (если можно) или возьмите.');
      showToast(`ИИ атакует: ${card.rank}${card.suit}`);
      updateUI();
    } else {
      setMessage('ИИ ожидает вашу защиту.');
      updateUI();
    }
  }

  function aiMaybeAddMore() {
    if (state.gameOver || state.isDealing) return;
    if (state.attacker !== 'ai') return;
    let added = false;
    while (true) {
      const defender = state.player;
      if (!canAddMore(defender)) break;
      const ranks = ranksOnTable();
      let candidates = state.ai.hand.filter(c => ranks.has(c.rank));
      if (state.deck.length === 0 && candidates.length > 1) {
        const rc = countRanksInHand(state.ai.hand);
        candidates.sort((a,b)=>{
          const ad = (rc.get(a.rank)||0) >= 2 ? 0 : 1;
          const bd = (rc.get(b.rank)||0) >= 2 ? 0 : 1;
          if (ad !== bd) return ad - bd;
          const at = a.suit === state.trumpSuit ? 1 : 0;
          const bt = b.suit === state.trumpSuit ? 1 : 0;
          if (at !== bt) return at - bt;
          return a.value - b.value;
        });
      }
      if (candidates.length === 0) break;
      const addCard = chooseLowest(candidates, true);
      removeFromHand(state.ai, addCard.id);
      state.tablePairs.push({ attack: addCard, defense: null });
      added = true;
      updateUI();
      break; // step-by-step
    }
    if (!added) {
      setMessage('ИИ завершил атаку: Бито.');
      endBoutSuccessfulDefense();
    } else {
      setMessage('ИИ подкинул. Побейте карту или возьмите.');
      updateUI();
    }
  }

  // Superpowers
  function usePeek() {
    if (state.superUsed || state.isDealing || state.gameOver) return;
    state.superUsed = true;
    state.peekActive = true;
    setMessage('Суперсила: вы подсмотрели карты ИИ на 6 секунд.');
    updateUI();
    setTimeout(() => { state.peekActive = false; updateUI(); }, 6000);
  }

  async function useSwapHand() {
    if (state.superUsed || state.isDealing || state.gameOver) return;
    if (state.player.hand.length === 0) { setMessage('У вас нет карт для замены.'); return; }

    state.superUsed = true;
    state.isDealing = true;
    setMessage('Суперсила: замена вашей руки на случайные карты из колоды...');
    updateUI();

    // Move player's current hand back into deck and reshuffle
    const old = state.player.hand.splice(0);
    state.deck.push(...old);
    // Keep trump suit unchanged; we keep trumpRefRank as initially set
    shuffle(state.deck);

    // Deal the same number of cards back to player (animated)
    const need = old.length;
    for (let i=0; i<need; i++) {
      if (state.deck.length === 0) break;
      await animateDealOne(state.player);
    }
    state.isDealing = false;
    setMessage('Рука заменена.');
    updateUI();
  }
  // (shuffle feature removed)

  // Buttons and controls
  el.newGameBtn.addEventListener('click', async () => { await startGame(); });
  if (el.endAttackBtn) el.endAttackBtn.addEventListener('click', async () => {
    if (state.isDealing || state.gameOver) return;
    if (state.attacker !== 'player') return;
    if (state.phase === 'dogonka') {
      setMessage('Завершаем догонку: противник берёт карты.');
      await defenderTakes(state.ai);
      return;
    }
    if (!allDefended()) return;
    setMessage('Бито. Завершаем взятку.');
    await endBoutSuccessfulDefense();
  });
  el.endAttackBtn2.addEventListener('click', async () => {
    if (state.isDealing || state.gameOver) return;
    if (state.attacker !== 'player') return;
    if (state.phase === 'dogonka') {
      setMessage('Завершаем догонку: противник берёт карты.');
      await defenderTakes(state.ai);
      return;
    }
    if (!allDefended()) return;
    setMessage('Бито. Завершаем взятку.');
    await endBoutSuccessfulDefense();
  });
  if (el.takeBtn) el.takeBtn.addEventListener('click', async () => {
    if (state.isDealing || state.gameOver) return;
    if (state.attacker !== 'ai') return;
    if (!tableHasUndefended()) return;
    const target = state.tablePairs.find(p => p.defense == null)?.attack;
    if (target) {
      state.memory.playerDislikeScore[target.suit] = (state.memory.playerDislikeScore[target.suit] || 0) + 1;
    }
    setMessage('Вы берёте карты. ИИ может докинуть вдогонку...');
    await aiDogonkaThenPlayerTakes();
  });
  el.takeBtn2.addEventListener('click', async () => {
    if (state.isDealing || state.gameOver) return;
    if (state.attacker !== 'ai') return;
    if (!tableHasUndefended()) return;
    const target = state.tablePairs.find(p => p.defense == null)?.attack;
    if (target) {
      state.memory.playerDislikeScore[target.suit] = (state.memory.playerDislikeScore[target.suit] || 0) + 1;
    }
    setMessage('Вы берёте карты. ИИ может докинуть вдогонку...');
    await aiDogonkaThenPlayerTakes();
  });
  el.resetScoreBtn.addEventListener('click', () => {
    state.playerScore = 0; state.aiScore = 0; updateScoreBoard(); setMessage('Счёт сброшен.');
  });
  el.peekBtn.addEventListener('click', () => usePeek());
  el.swapBtn.addEventListener('click', async () => { await useSwapHand(); });
  el.transferModeChk.addEventListener('change', (e) => {
    state.transferModePlanned = !!e.target.checked;
    setMessage(state.transferModePlanned ? 'Режим: Переводной будет применён со следующей новой игры' : 'Режим: Переводной выключен (вступит со следующей новой игры)');
    updateModeNotes();
  });
  el.doubleTrumpChk.addEventListener('change', (e) => {
    state.doubleTrumpPlanned = !!e.target.checked;
    setMessage(state.doubleTrumpPlanned ? 'Режим: Двойной козырь будет применён со следующей новой игры' : 'Режим: Двойной козырь выключен (вступит со следующей новой игры)');
    updateModeNotes();
  });
  // removed shuffle and advisor handlers
  el.fastBtn.addEventListener('click', () => {
    state.fastDeal = !state.fastDeal;
    el.fastBtn.textContent = `Быстрая раздача: ${state.fastDeal ? 'вкл' : 'выкл'}`;
  });
  // shuffle removed

  // Hand scrolling UX: drag-to-scroll and wheel horizontal
  function enableHandScrolling(container) {
    let isDown = false, startX = 0, scrollLeft = 0;
    container.addEventListener('mousedown', (e) => {
      isDown = true; startX = e.pageX - container.offsetLeft; scrollLeft = container.scrollLeft; container.classList.add('dragging');
    });
    container.addEventListener('mouseleave', () => { isDown = false; container.classList.remove('dragging'); });
    container.addEventListener('mouseup', () => { isDown = false; container.classList.remove('dragging'); });
    container.addEventListener('mousemove', (e) => {
      if (!isDown) return; e.preventDefault(); const x = e.pageX - container.offsetLeft; const walk = (x - startX) * 1; container.scrollLeft = scrollLeft - walk;
    });
    // Touch support for Android/iOS
    let tStartX = 0, tScrollLeft = 0;
    container.addEventListener('touchstart', (e) => {
      const t = e.touches[0]; tStartX = t.clientX; tScrollLeft = container.scrollLeft;
    }, { passive: true });
    container.addEventListener('touchmove', (e) => {
      if (e.touches.length !== 1) return; const t = e.touches[0]; const dx = t.clientX - tStartX; container.scrollLeft = tScrollLeft - dx;
    }, { passive: true });
    container.addEventListener('wheel', (e) => {
      if (Math.abs(e.deltaY) > Math.abs(e.deltaX)) {
        container.scrollLeft += e.deltaY; e.preventDefault();
      }
    }, { passive: false });
  }

  // Zoom controls
  let zoomScale = 1.0;
  const zoomStep = 0.1;
  const minScale = 0.6;
  const maxScale = 1.4;
  document.getElementById('zoomInBtn').addEventListener('click', () => {
    zoomScale = Math.min(maxScale, zoomScale + zoomStep);
    applyZoom(zoomScale);
    updateUI();
  });
  document.getElementById('zoomOutBtn').addEventListener('click', () => {
    zoomScale = Math.max(minScale, zoomScale - zoomStep);
    applyZoom(zoomScale);
    updateUI();
  });

  // Init
  const restored = tryRestoreState();
  if (!restored) {
    setMessage('Нажмите «Новая игра», чтобы начать. Доступны суперсилы (1 раз за игру) и режим «Переводной».');
  }
  updateUI();

  // If we restored during dealing, continue it
  if (restored && state.isDealing && state.dealContext) {
    if (state.dealContext === 'initial') {
      initialDealAnimated().then(()=>{
        if (state.phase === 'between' || state.phase === 'idle') {
          // Likely in middle of startGame flow; continue selection of attacker
          determineFirstAttacker();
          state.phase = (state.attacker === 'player') ? 'attack' : 'ai_turn';
          setMessage(state.attacker === 'player' ? 'Ваш ход: сыграйте любую карту для атаки.' : 'Ход ИИ: ожидайте.');
          updateUI();
          if (state.attacker === 'ai') setTimeout(aiTurn, 600);
        }
      });
    } else if (state.dealContext === 'refill') {
      drawUpToSixAnimated(state.dealAttackerFirst).then(()=>{
        if (state.postDeal && state.postDeal.type === 'successfulDefense') {
          endBoutSuccessfulDefense();
        } else if (state.postDeal && state.postDeal.type === 'defenderTakes') {
          defenderTakes(state.attacker === 'player' ? state.ai : state.player);
        }
      });
    }
  }

  // Collapsible groups: toggle on title click
  function wireGroupCollapsing() {
    const groups = document.querySelectorAll('.toolbar .group');
    groups.forEach((g) => {
      const title = g.querySelector('.title');
      if (!title) return;
      title.addEventListener('click', (e) => {
        // avoid toggling when clicking inner controls inside title later
        g.classList.toggle('collapsed');
      });
    });
  }
  wireGroupCollapsing();

  // Mobile default: collapse all except game
  function applyMobileDefaults() {
    const isMobile = window.matchMedia('(max-width: 768px)').matches;
    if (!isMobile) return;
    const groups = document.querySelectorAll('.toolbar .group');
    groups.forEach((g) => {
      if (g.id === 'group-game') return;
      g.classList.add('collapsed');
    });
  }
  applyMobileDefaults();

  // Enable hand scrolling after DOM is ready
  requestAnimationFrame(() => {
    const ph = document.getElementById('playerHand');
    const oh = document.getElementById('opHand');
    if (ph) enableHandScrolling(ph);
    if (oh) enableHandScrolling(oh);
  });

  // AI dogonka: when the player chooses to take, AI may add more cards up to the allowed cap
  async function aiDogonkaThenPlayerTakes() {
    if (state.gameOver || state.isDealing) return;
    if (state.attacker !== 'ai') return;
    const defender = state.player;
    let addedAny = false;
    while (canAddMore(defender)) {
      const ranks = ranksOnTable();
      const candidates = state.ai.hand.filter(c => ranks.has(c.rank));
      if (candidates.length === 0) break;
      const addCard = chooseLowest(candidates, true);
      removeFromHand(state.ai, addCard.id);
      state.tablePairs.push({ attack: addCard, defense: null });
      addedAny = true;
      updateUI();
      await sleep(320);
    }
    if (addedAny) setMessage('ИИ докинул карты. Вы берёте.');
    await defenderTakes(state.player);
  }
})();
</script>
</body>
</html>
